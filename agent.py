# agent.py
"""
An AI-powered agent to automatically generate, test, and validate
Python parsers for bank statement PDFs.
"""

import argparse
import subprocess
import sys
import os
import csv
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any

import google.generativeai as genai
from groq import Groq
from dotenv import load_dotenv

# --- Configuration ---
load_dotenv()
MAX_ATTEMPTS = 3
PARSERS_DIR = Path("custom_parsers")

# --- API Initialization ---
def initialize_clients() -> Dict[str, Any]:
    """Loads API keys and configures API clients."""
    gemini_api_key = os.getenv("GEMINI_API_KEY")
    groq_api_key = os.getenv("GROQ_API_KEY")

    if not gemini_api_key or not groq_api_key:
        print("⚠️  Warning: API keys not found in .env file.")
        print("Please copy .env.example to .env and add your keys.")

    genai.configure(api_key=gemini_api_key)
    return {
        "gemini": genai.GenerativeModel("gemini-1.5-flash"),
        "groq": Groq(api_key=groq_api_key),
    }

class ParserAgent:
    """
    An agent that generates and validates PDF parsing code for bank statements.
    """
    def __init__(self, bank_name: str, preferred_backend: Optional[str]):
        """
        Initializes the agent with a target bank and AI backend.

        Args:
            bank_name: The target bank identifier (e.g., 'icici').
            preferred_backend: The user's preferred AI backend ('gemini' or 'groq').
        """
        self.bank_name = bank_name.lower()
        self.clients = initialize_clients()
        self.backend = self._select_backend(preferred_backend)

        # Define file paths
        self.pdf_path = Path(f"data/{self.bank_name}/{self.bank_name}_sample.pdf")
        self.csv_path = Path(f"data/{self.bank_name}/{self.bank_name}_sample.csv")
        self.parser_path = PARSERS_DIR / f"{self.bank_name}_parser.py"

    def _select_backend(self, preferred: Optional[str]) -> str:
        """Selects the AI backend, defaulting to 'gemini'."""
        if preferred in ["gemini", "groq"]:
            return preferred
        return "gemini"

    def _get_ai_response(self, prompt: str) -> str:
        """
        Calls the selected AI model to get a response.

        Args:
            prompt: The prompt to send to the AI model.

        Returns:
            The text response from the AI.
        """
        if self.backend == "gemini":
            resp = self.clients["gemini"].generate_content(prompt)
            return resp.text
        elif self.backend == "groq":
            resp = self.clients["groq"].chat.completions.create(
                model="llama-3.1-8b-instant",
                messages=[{"role": "user", "content": prompt}],
            )
            return resp.choices[0].message.content
        else:
            raise ValueError(f"Unknown backend: {self.backend}")

    def _generate_parser_script(self, csv_content: str) -> str:
        """
        Generates the Python parser code using the AI model.

        Args:
            csv_content: A string sample of the target CSV file.

        Returns:
            The raw Python code generated by the AI.
        """
        csv_headers = csv_content.splitlines()[0]
        dict_keys = csv_headers.split(',')

        prompt = f"""
You are an expert Python developer. Your task is to write a Python script to parse a bank statement PDF.

**Instructions:**
1.  **Strictly Python Code Only:** Do not include any explanatory text, comments, or markdown formatting like ```python. Your entire output must be valid Python code.
2.  **Function Signature:** The script must contain a function with this exact signature: `parse_pdf(pdf_path: str) -> list[dict]`
3.  **Library:** Use the `pdfplumber` library for PDF processing.
4.  **Target Bank:** {self.bank_name}
5.  **Output Format:** The function must return a list of dictionaries. Each dictionary represents a transaction.
6.  **Dictionary Keys:** The keys for each dictionary must be exactly: {dict_keys}
7.  **Data Extraction:** The function should extract transaction data from the text of the PDF.
8.  **Empty Values:** If a value is not found for a key, it should be an empty string `""`.

Begin writing the code now.
"""
        return self._get_ai_response(prompt)

    @staticmethod
    def _clean_and_write_script(script_content: str, destination_path: Path) -> None:
        """
        Cleans the AI-generated code and writes it to a file.

        Args:
            script_content: The raw code from the AI.
            destination_path: The path to save the final .py file.
        """
        # Remove markdown code fences
        clean_code = script_content.replace("```python", "").replace("```", "")
        
        # Remove null bytes and other common artifacts
        clean_code = clean_code.replace("\x00", "").replace("\ufeff", "")

        # Find the first valid line of code to discard any preamble
        lines = clean_code.splitlines()
        code_start_index = 0
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped.startswith(('import ', 'from ', 'def ', 'class ')):
                code_start_index = i
                break
        
        final_code = "\n".join(lines[code_start_index:]).strip()

        # Ensure the parent directory exists and write the file
        destination_path.parent.mkdir(exist_ok=True)
        destination_path.write_text(final_code, encoding="utf-8")
        print(f"✅ Wrote parser to {destination_path}")

    # This is the NEW, corrected method for agent.py
    def _test_generated_parser(self) -> bool:
        """
        Runs the pytest contract test against the generated parser.

        Returns:
            True if tests pass, False otherwise.
        """
        print(f"🔍 Running tests for {self.bank_name}...")
        command = [
            sys.executable, "-m", "pytest",
            # 👇 This line has been updated to match the new test file structure 👇
            f"tests/test_parser_contract.py::TestParserContract::test_parser_structure_and_output[{self.bank_name}]",
            "-v"
        ]
        result = subprocess.run(command, capture_output=True, text=True, check=False)

        print(result.stdout)
        if result.stderr:
            print("--- STDERR ---")
            print(result.stderr)

        return result.returncode == 0

    def _display_debug_output(self, attempt: int) -> None:
        """Shows expected vs. generated CSV on test failure."""
        print("❌ Tests failed. Displaying output for debugging...")
        try:
            # 1. Show expected CSV
            expected_content = self.csv_path.read_text(encoding="utf-8").strip()
            print("\n" + "="*20 + " EXPECTED CSV " + "="*20)
            print(expected_content)
            print("="*54 + "\n")

            # 2. Run generated parser and show its output
            spec = importlib.util.spec_from_file_location(f"{self.bank_name}_parser", self.parser_path)
            parser_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(parser_module)
            generated_data = parser_module.parse_pdf(self.pdf_path)

            print("="*20 + " GENERATED CSV " + "="*19)
            if generated_data and isinstance(generated_data, list) and generated_data[0]:
                output_path = Path(f"generated_{self.bank_name}_output_attempt_{attempt}.csv")
                with output_path.open("w", newline="", encoding="utf-8") as f:
                    writer = csv.DictWriter(f, fieldnames=generated_data[0].keys())
                    writer.writeheader()
                    writer.writerows(generated_data)
                print(output_path.read_text(encoding="utf-8").strip())
                print(f"\n(Generated output saved to {output_path})")
            else:
                print("(Parser returned no data or data in an invalid format)")
            print("="*54)

        except Exception as e:
            print(f"\n⚠️  Could not run generated parser for debugging: {e}")

    def run(self) -> None:
        """
        Executes the main loop to generate, write, and test the parser.
        """
        # Validate that sample files exist before starting
        if not self.pdf_path.exists() or not self.csv_path.exists():
            print(f"🚨 Error: Missing sample files in data/{self.bank_name}/")
            print(f"  - Expected: {self.pdf_path.name}")
            print(f"  - Expected: {self.csv_path.name}")
            return

        csv_content = self.csv_path.read_text(encoding="utf-8")

        for attempt in range(1, MAX_ATTEMPTS + 1):
            print(f"\n🌀 Attempt {attempt}/{MAX_ATTEMPTS} using {self.backend}...")
            
            raw_script = self._generate_parser_script(csv_content)
            self._clean_and_write_script(raw_script, self.parser_path)

            if self._test_generated_parser():
                print("✅ Tests passed! Parser generated successfully.")
                return
            else:
                self._display_debug_output(attempt)
                if attempt < MAX_ATTEMPTS:
                    print("\nRetrying...\n")

        print(f"🚨 Failed to generate a passing parser after {MAX_ATTEMPTS} attempts.")


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="AI Agent for Bank Statement Parser Generation."
    )
    parser.add_argument(
        "--target",
        required=True,
        help="The bank to target (e.g., 'icici'). Must have a corresponding folder in '/data'."
    )
    parser.add_argument(
        "--backend",
        choices=["gemini", "groq"],
        default=None,
        help="Specify the AI backend to use. Defaults to Gemini."
    )
    args = parser.parse_args()

    agent = ParserAgent(bank_name=args.target, preferred_backend=args.backend)
    agent.run()


if __name__ == "__main__":
    main()